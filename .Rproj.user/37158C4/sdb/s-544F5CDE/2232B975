{
    "contents" : "\n#\n# Compute the Euclidean distance between two vectors\n#\ndistEuclidean <- function(x1, x2) {\n  \n  result <- sqrt(sum((x1-x2)^2))\n  \n  return(result)\n}\n\n#\n# Get the distances between a given item and every item in the dataset\n#\ngetDistance <- function(X, Y) {\n  \n  # initialize result matrix\n  nbTestRows <- dim(Y)[1]\n  nbTrainRows <- dim(X)[1]\n  result <- matrix(0,nbTestRows, nbTrainRows)\n  \n  for (i in 1:nbTestRows) {\n    for (j in 1:nbTrainRows) {\n      vec1 <- Y[i,]\n      vec2 <- X[j,]\n      result[i,j] <- distEuclidean(vec1, vec2)\n    }\n  }\n  \n  return(result)\n}\n\n#\n# knnSearch find the nearest neighbors\n#\n# Finds the nearest neighbor in X for each point in Y. \n# X is an mx-by-n matrix and Y is an my-by-n matrix. \n# Rows of X and Y correspond to observations and columns correspond to variables.\nknnSearch <- function(X, Y, k) {  \n  \n  # initialize result matrix\n  nbTestRows <- dim(Y)[1]\n  result <- matrix(0,nbTestRows,k)\n  \n  # Compute the distance between every itemX and a given itemY\n  distList <- getDistance(X, Y)\n  \n  # Finds the nearest neighbors\n  for (i in 1:nbTestRows) {\n    temp <- sort(distList[i,])\n    result[i,] <- match(temp[1:k], distList[i,])\n  }\n  \n  return(result)\n}\n\n#\n# Get the complete ranks associated to the nearest neighbors\n#\n#\ngetRanks <- function(cvTrainClasses, instance) {\n  \n  # initialize result matrix\n  ranks <- data.frame(Ranks=cvTrainClasses[instance[1,]])\n  \n  for (i in 1:dim(instance)[1]) {\n    ranks[i] <- data.frame(Ranks=cvTrainClasses[instance[i,]])\n  }\n  \n  return(ranks)\n}\n\n#\n# Get the index of the each fold {train and test dataset}\n#\n# input: 145 instances, 10 folds\n# output:\n#   Fold  TestS TestE TrainS1 TrainE1 TrainS2 TrainE2\n#   1     1     15    16      145     -       -\n#   2     16    30    1       15      31      145\n#   3     31    45    1       30      46      145\n#   .\n#   .\n#   .\n#   9     121   135   1       120     136     145\n#   10    136   145   1       135     -       -\n#\ngetFold <- function(dsetRowNumber, fold) {\n  \n  # Divide the dataset according to the number of folds \n  numberOfRowsPerFold <- ceiling(dsetRowNumber/fold)\n  testS <- 0 # Test index of start row at fold i-th\n  testE <- 0 # Test index of end row at fold i-th\n  trainS1 <- 0 # Train index of start row at fold i-th, 1st portion\n  trainE1 <- 0 # Train index of end row at fold i-th, 1st portion\n  trainS2 <- 0 # Train index of start row at fold i-th, 2nd portion\n  trainE2 <- 0 # Train index of end row at fold i-th, 2nd portion\n  result <- data.frame(Fold=0, TestS=0, TestE=0, TrainS1=0, TrainE1=0, TrainS2=0, TrainE2=0)\n  \n  i<-0\n  for (startOfRow in seq(1,dsetRowNumber,numberOfRowsPerFold)) {\n    i<-i+1\n    testS <- startOfRow\n    testE <- startOfRow+numberOfRowsPerFold-1\n    \n    if (startOfRow == 1) { # 1st fold\n      trainS1 <- testE+1\n      trainE1 <- dsetRowNumber\n    } else {\n      if (i == fold) {  # last fold\n        testE <- dsetRowNumber\n        trainS1 <- 1\n        trainE1 <- testS-1\n        trainS2 <- 0\n        trainE2 <- 0\n      } else { # folds in between 1st and lat\n        trainS1 <- 1\n        trainE1 <- testS-1\n        trainS2 <- testE+1\n        trainE2 <- dsetRowNumber\n      }\n    }        \n    \n    result[i,] <- data.frame(i, testS, testE, trainS1, trainE1, trainS2, trainE2)\n    \n  } # end for\n  \n  return(result)\n  \n}\n\n#\n# sortRandom create a randomCol using for sorting the dataset\n# sort the dataset accoding to the randomCol \n# this gives cross validation randomness\n#\nsortRandom <- function(dset) {\n  \n  dsetRowNumber <- dim(dset)[1] # Total number of rows\n  set.seed(1)\n  randomCol <- runif(dsetRowNumber) # A random column\n  temp <- cbind(randomCol,dset)\n  dsetSorted <- temp[order(temp$randomCol),]\n  \n  return(dsetSorted)\n  \n}",
    "created" : 1404675752007.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2001214893",
    "id" : "2232B975",
    "lastKnownWriteTime" : 4611686018427408896,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "r_source"
}